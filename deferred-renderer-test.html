<!doctype html>
<html lang="en">
<head>
	<title>Andrew Moore Zone</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
<link rel="stylesheet" href="css/bootstrap.min.css" />
<link rel="stylesheet" href="css/bootstrap-theme.css" />

<script src="js/three.min.js"></script>

<script src="js/Detector.js"></script>

<script src="js/jquery.js"></script>

<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.WindowResize.js"></script>

<script src="js/CSS3DRenderer.js"></script>

<script src="js/bootstrap.min.js"></script>

<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/BloomPass.js"></script>

<script src="js/renderers/WebGLDeferredRenderer.js"></script>

<script src="js/ShaderDeferred.js"></script>
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script src="js/shaders/ConvolutionShader.js"></script>

<!--append to the bodyplease xx.??///script] -->
<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>

$('#info-modal').modal({
  keyboard: false
});


var container, scene, camera, renderer, cssRenderer, cssScene;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

var wallsWidth = 20;
var wallsHeight = 150;

var targetList = [];
var projector, mouse = { x: 0, y: 0 };

var infoModalLookup = [];

// Info Boxes.
var MFGInfo = {
	title: "Mother Fucker Galaxy",
	body: "Ummhh......",
	buttonText: "Ok, cool.",
	display: function(){
		$("#modal-title").html(this.title);
		$("#modal-body-p").html(this.body);
		$("#modal-button").html(this.buttonText);
		$("#info-modal").modal('show');
	}
};



document.addEventListener( 'mousedown', onDocumentMouseDown, false );

init();
animate();

// FUNCTIONS 		
function init() 
{

	projector = new THREE.Projector();

	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,40,1100);
	camera.lookAt(scene.position);	
	camera.rotation.x = 0;
	
	// RENDERER
	//if ( Detector.webgl )
	//	renderer = new THREE.WebGLRenderer( {antialias:true} );
	//else
	//	renderer = new THREE.CanvasRenderer(); 

	renderer = new THREE.WebGLDeferredRenderer( { width: SCREEN_WIDTH, height: SCREEN_HEIGHT, scale: 1, antialias: true, tonemapping: THREE.FilmicOperator, brightness: 2.5 } );

	/*
	renderer.shadowMapEnabled = true;
	renderer.shadowMapSoft = true;

	renderer.shadowCameraNear = 3;
	renderer.shadowCameraFar = camera.far;
	renderer.shadowCameraFov = 1;

	renderer.shadowMapBias = 0.0039;
	renderer.shadowMapDarkness = 0.8;
	renderer.shadowMapWidth = 10000;
	renderer.shadowMapHeight = 10000;
	renderer.shadowMapType = THREE.PCFShadowMap;

	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
*/
	//var bloomEffect = new THREE.BloomPass( 0.65 );
	//renderer.addEffect( bloomEffect );

	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);

	collidableMeshList = [];
	
	cameraColGeo = new THREE.CubeGeometry(40, 40, 40, 4, 4, 4);
	cameraColMat = new THREE.MeshBasicMaterial({ visible: false, color: 0x00ff00});
	cameraColMesh = new THREE.Mesh(cameraColGeo, cameraColMat);
	cameraColMesh.position.set(0,40,1100);
	scene.add(cameraColMesh);


	//THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	//controls = new THREE.OrbitControls( camera, renderer.domElement );
	// STATS
	//stats = new Stats();
	//stats.domElement.style.position = 'absolute';
	//stats.domElement.style.bottom = '0px';
	//stats.domElement.style.zIndex = 100;
	//container.appendChild( stats.domElement );
	// LIGHT



	var light = new THREE.AreaLight( 0x00ff00, 1 );
	//light.position.set( 0.0001, 10.0001, -18.5001 );
	//light.rotation.set( 0, 0.0001, 0.0001 );
	light.width = 200;
	light.height = 200;
	light.position.set(0,40,1000);
	
	scene.add(light);
	//light.castShadow = true;
	//light.shadowDarkness = 0.5;
	


	//light.target = new THREE.Vector3(1000,0,0);

	// FLOOR
	var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );

	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(4000, 4000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -0.5;
	floor.rotation.x = Math.PI / 2;
	floor.receiveShadow = true;
	scene.add(floor);


	// Walls
	var wallGeo = new THREE.CubeGeometry(4000,300,20,1,1,1);
	var wallMat = new THREE.MeshBasicMaterial({color: 0xaaee00});
	var wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(0,150,1990);
	scene.add(wall);
	collidableMeshList.push(wall);

	InitStructure();

	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	// scene.add(skyBox);
	scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
	scene.add(skyBox);


	// CSS3D 
	cssScene = new THREE.Scene();

	CSS3DElementsInit()

	cssRenderer = new THREE.CSS3DRenderer();
	cssRenderer.setSize( window.innerWidth, window.innerHeight );
	cssRenderer.domElement.style.position = 'absolute';
	cssRenderer.domElement.style.top = 0;

	document.body.appendChild(cssRenderer.domElement);

	THREEx.WindowResize(cssRenderer, camera);

	renderer.domElement.style.zIndex = 1;
	renderer.domElement.style.top = 0;
	renderer.domElement.style.position = 'absolute';
	cssRenderer.domElement.appendChild(renderer.domElement);

}


function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	var delta = clock.getDelta(); // seconds.
	var moveDistance = 200 * delta; // 200 pixels per second
	var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second

	cameraColMesh.position.set(camera.position.x, camera.position.y, camera.position.z);

	// move forwards/backwards/left/right
	if ( keyboard.pressed("W") ){
		var camBefore = camera.position;
		camera.translateZ( -moveDistance );	
		if (!canMoveTo(camBefore, camera.position)){ camera.translateZ( moveDistance ); }			
	}

	if ( keyboard.pressed("S") ){
		var camBefore = camera.position;
		camera.translateZ(  moveDistance );
		if (!canMoveTo(camBefore, camera.position)){ camera.translateZ( -moveDistance ); }
		
	}

	if ( keyboard.pressed("Q") ){
		var camBefore = camera.position;
		camera.translateX( -moveDistance );
		if (!canMoveTo(camBefore, camera.position)){ camera.translateX( moveDistance ); }		
		
	}
		
	if ( keyboard.pressed("E") ){
		var camBefore = camera.position;
		camera.translateX(  moveDistance );
		if (!canMoveTo(camBefore, camera.position)){ camera.translateX(  -moveDistance );}		
			
	}
		

	// rotate left/right/up/down
	var rotation_matrix = new THREE.Matrix4().identity();
	if ( keyboard.pressed("A") )
		camera.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
	if ( keyboard.pressed("D") )
		camera.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
	if ( keyboard.pressed("R") )
		camera.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
	if ( keyboard.pressed("F") )
		camera.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);

	if ( keyboard.pressed("Z") )
	{
		camera.position.set(0,40,0);
		camera.rotation.set(0,0,0);
	}

}

function canMoveTo(vBefore, vAfter){
	if (vAfter.x > 2000 || vAfter.x < -2000){ return false; }
	if (vAfter.z > 2000 || vAfter.z < -2000){ return false; }

	for(var vi = 0; vi < cameraColMesh.geometry.vertices.length; vi++){
		var localVertex = cameraColMesh.geometry.vertices[vi].clone();
		var globalVertex = localVertex.applyMatrix4(cameraColMesh.matrix);
		var directionVector = globalVertex.sub(cameraColMesh.position);
	
		var colRay = new THREE.Raycaster(vAfter, directionVector.clone().normalize());
		var colResult = colRay.intersectObjects(collidableMeshList);
		if (colResult.length > 0 && colResult[0].distance < directionVector.length()){
			return false;
			break;
		}
	}

	return true;
}

function render() 
{
	cssRenderer.render(cssScene, camera);
	renderer.render( scene, camera );
}

function CSS3DElementsInit(){
	var planeMaterial   = new THREE.MeshBasicMaterial({color: 0x000000, opacity: 0.1, side: THREE.DoubleSide });
	var planeWidth = 200;
    var planeHeight = 120;
	var planeGeometry = new THREE.PlaneGeometry( planeWidth, planeHeight );
	var planeMesh= new THREE.Mesh( planeGeometry, planeMaterial );
	planeMesh.position.y += planeHeight/2;
	planeMesh.position.x = 500;
	planeMesh.position.z = -150;
	// add it to the standard (WebGL) scene
	scene.add(planeMesh);

	// create the dom Element
	var element = document.createElement( 'iframe' );
	element.src = 'http://dangerneck.hosting24.com.au/games/mfg.html';
	var elementWidth = 1024;
	// force iframe to have same relative dimensions as planeGeometry
	var aspectRatio = planeHeight / planeWidth;
	var elementHeight = elementWidth * aspectRatio;
	element.style.width  = elementWidth + "px";
	element.style.height = elementHeight + "px";

	// create the object3d for this element
	var cssObject = new THREE.CSS3DObject( element );
	// we reference the same position and rotation 
	cssObject.position = planeMesh.position;
	cssObject.rotation = planeMesh.rotation;
	var percentBorder = 0.05;
	cssObject.scale.x /= (1 + percentBorder) * (elementWidth / planeWidth);
	cssObject.scale.y /= (1 + percentBorder) * (elementWidth / planeWidth);
	// add it to the css scene
	cssScene.add(cssObject);
}

function InitStructure(){
	wallMat = new THREE.MeshBasicMaterial({color: 0xaabbcc});
	infoBoxMat = new THREE.MeshBasicMaterial({color: 0x00ffaa});

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(0,wallsHeight/2,1200);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;

	collidableMeshList.push(wall);

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(100,wallsHeight/2,1100);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-100,wallsHeight/2,1100);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-200,wallsHeight/2,1000);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(200,wallsHeight/2,1000);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);		

	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(300,wallsHeight/2,800);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-300,wallsHeight/2,800);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-200,wallsHeight/2,600);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(200,wallsHeight/2,600);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-100,wallsHeight/2,500);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(100,wallsHeight/2,500);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);				

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(200,wallsHeight/2,400);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(200,wallsHeight/2,200);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-200,wallsHeight/2,400);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-200,wallsHeight/2,200);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);			

 	// Big Rooms
	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-500,wallsHeight/2,600);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);		
	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(500,wallsHeight/2,600);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);		

	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(300,wallsHeight/2,500);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);
	wallGeo = new THREE.CubeGeometry(200 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-300,wallsHeight/2,500);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-500,wallsHeight/2,-200);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);		
	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(500,wallsHeight/2,-200);
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);			

	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(300,wallsHeight/2,0);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);
	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-300,wallsHeight/2,0);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);

	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(100,wallsHeight/2,0);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);
	wallGeo = new THREE.CubeGeometry(400 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-100,wallsHeight/2,0);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	wallGeo = new THREE.CubeGeometry(800 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(700,wallsHeight/2,200);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);
	wallGeo = new THREE.CubeGeometry(800 + wallsWidth,wallsHeight,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(-700,wallsHeight/2,200);
	wall.rotation.y = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true; wall.receiveShadow = true;
	collidableMeshList.push(wall);	

	// Roof
	wallGeo = new THREE.CubeGeometry(1400 + wallsWidth,1600,wallsWidth,1,1,1);	
	wall = new THREE.Mesh(wallGeo, wallMat);
	wall.position.set(0,wallsHeight,400);
	wall.rotation.x = Math.PI /2;
	scene.add(wall);
	wall.castShadow = true;
	collidableMeshList.push(wall);		


	// Clickable info boxes
	wallGeo = new THREE.CubeGeometry(40 ,60,10,1,1,1);	
	wall = new THREE.Mesh(wallGeo, infoBoxMat);
	wall.position.set(350,30,-150);
	wall.rotation.y = Math.PI /6;
	scene.add(wall);
	collidableMeshList.push(wall);	
	//targetList.push(wall);	
	infoModalLookup[wall.id] = MFGInfo;
	


}

function onDocumentMouseDown(event){
	// the following line would stop any other event handler from firing
	// (such as the mouse's TrackballControls)
	// event.preventDefault();

	console.log("Click.");

	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	// find intersections

	// create a Ray with origin at the mouse position
	//   and direction into the scene (camera direction)
	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	projector.unprojectVector( vector, camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( collidableMeshList )

	// if there is one (or more) intersections
	if ( intersects.length > 0)
	{

		objectId = intersects[0].object.id;
		if (infoModalLookup[objectId] != null){
			infoModalLookup[objectId].display();
		}
		// add list of interactable objects here.
	}
}

</script>

<div class="modal fade" id="info-modal">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <h4 class="modal-title" id="modal-title">Modal title</h4>
      </div>
      <div class="modal-body">
        <p id="modal-body-p">One fine body&hellip;</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal" id="modal-button">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->

</body>
</html>